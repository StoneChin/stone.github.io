---
title: C++学习笔记
published: 2024-04-10
description: "C++ learning notes."
image: ""
tags: [note, C++]
category: Study
draft: false
---

## C++

### 1.1 多态（⭐⭐⭐）
同一个函数在不同的上下文中的多种形态。C++氛围编译时多态（静态）和运行时多态（动态）。

1. 多态性定义：
多态性是面向对象编程（OOP）中的一个特性，允许不同类的对象通过相同的接口调用各自不同的实现方法。多态性主要分为两类：
* 编译时多态（静态多态）：通过函数重载和运算符重载实现。
* 运行时多态（动态多态）：通过虚函数实现。

2. 虚函数：
虚函数是通过在基类中使用 virtual 关键字声明的函数，允许在派生类中重写。通过基类指针或引用调用虚函数时，会根据实际对象类型调用相应的重写版本。

3. 纯虚函数：
纯虚函数是没有实现的虚函数，在基类中使用 = 0 声明。包含纯虚函数的类称为抽象类，不能实例化。

4. 虚表（V-Table）：
当一个类包含虚函数时，编译器会为该类生成一个虚函数表（虚表），其中存储了指向各个虚函数的指针。对象包含一个指向虚表的指针（虚表指针）。

#### 常见面试题
1. 解释多态性及其实现方式：

* 问题：什么是多态性？C++ 中如何实现多态性？
* 答案：多态性是允许不同对象通过相同接口调用不同实现的特性。C++ 中通过函数重载和运算符重载实现编译时多态，通过虚函数和继承实现运行时多态。

2. 虚函数和纯虚函数的区别：
* 问题：虚函数和纯虚函数有什么区别？
* 答案：虚函数在基类中有默认实现，派生类可以重写；纯虚函数在基类中没有实现，必须在派生类中实现，否则派生类也是抽象类，不能实例化。

3. 多态性的应用场景：
* 问题：在实际项目中，多态性有哪些应用场景？
* 答案：多态性常用于实现灵活的接口设计，例如通过基类指针或引用操作派生类对象，避免在代码中使用大量的条件语句（如 if-else 或 switch）。

4. 虚表（V-Table）机制：
* 问题：解释虚表机制及其工作原理。
* 答案：虚表是编译器为类生成的表，其中存储了指向虚函数的指针。对象包含一个指向虚表的指针，调用虚函数时通过虚表指针找到实际的函数地址，从而实现动态绑定。

5. 运行时多态性示例：
* 问题：编写一个简单的 C++ 程序，展示运行时多态性的用法。
* 答案：
```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "Base class" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived class" << endl;
    }
};

int main() {
    Base* b = new Derived();
    b->show();  // 输出：Derived class
    delete b;
    return 0;
}
```

6. 析构函数中的多态性：

>C++中，构造函数不可以是虚函数，而析构函数可以且常常是虚函数。

* 问题1：构造函数不可以是虚函数
* 答案1：因为构造函数的用途是初始化对象的状态，虚函数是为了实现多态，在对象构造时，虚函数表还未完全建立，且构造函数的调用顺序从基类到派生类，这样虚函数机制无法正确地工作。

* 问题2：为什么基类析构函数通常定义为虚函数？
* 答案2：如果基类析构函数不是虚函数，通过基类指针删除派生类对象时不会调用派生类的析构函数，导致资源泄漏。将基类析构函数定义为虚函数，可以确保正确调用派生类析构函数。


7. 虚函数表指针size：32位下4个字节
8. 虚函数表存储在的区域：常量区（因为编译好了，虚函数表也已经确定了不能改变）；
9. 虚函数指针存储在的区域：和创建的对象在堆上创建还是在栈上创建所区分的，跟着对象走；
10. 在构造函数和析构函数中使用虚函数：
* 构造函数：例如在基类的构造函数中使用虚函数，由于对象尚未完全构造，`vptr`指向基类的虚函数表，因此调用的是基类的版本;
* 析构函数： 在派生类析构函数中调用虚函数时，调用的是派生类的版本。但在进入基类析构函数后，调用的是基类的版本。这是因为在进入`Base`的析构函数时，`vptr`已经指向了`Base`的虚函数表。


### 1.2 内存模型，继承
可以参考这篇[博客](https://blog.csdn.net/mieleizhi0522/article/details/100674868)，很好的博客，使我虚函数指针旋转。

内存模型指的是C++中类对象的内存分布，一般有如下特点：
1. 有虚函数，虚函数指针时钟放在内存空间的头部；
2. 虚函数外，内存空间按类的继承顺序（父->子）和字段生命顺序布局；
3. 多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局（虚表指针+字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到`第一个虚函数表的后面`；
4. 如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(最上方的父类，包含虚表)，并且各个父类不再拷贝公共基类中的数据成员。
5. 菱形继承

### 1.3 内存管理（内存分配、内存对齐）（⭐⭐⭐）
#### 1. C++的内存区域：
1. 堆，使用malloc、free动态分配和释放空间，能分配较大的内存；
2. 栈，为函数的局部变量分配内存，能分配较小的内存；
3. 全局/静态存储区，用于存储全局变量和静态变量；
4. 常量存储区，专门用来存放常量；
5. 自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。

#### 2. 堆和栈的内存区别
1. 堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放；
2. 堆能分配的内存较大（4G(32位机器)），栈能分配的内存较小（1M）；
3. 在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片；
4. 堆的分配效率低，栈的分配效率高；
5. 堆地址从低向上，栈由高向下。

#### 3. malloc/free和new/delete的区别
1. new分配内存空间无需指定分配内存大小，malloc需要；
2. new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；
3. new是从自由存储区获得内存，malloc从堆中获取内存；
4. 对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。

#### 4. 什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？
1. 内存对其的原因：CPU存取数据为提高效率，计算机从内存中取数据是按照一个固定长度的。如32位机器，CPU每次都是取32bit即4字节数据。不对齐会出现

### 1.4 类型转换（⭐⭐）
#### 1. C风格类型转化
在变量前直接加数据类型
#### 2. C++风格类型转化关键字
* `static_cast`: `隐式/静态类型转换`，基本数据类型、指针类型、具有继承关系的类（处理不了无关关系的类型转换），编译期会做类型安全检查
* `dynamic_cast`: `动态类型转换`，基类指针或引用**安全地**->派生类指针或引用，转换失败返回`NULL`，父类必须有虚函数，运行期会做类型安全检查
* `const_cast`: 增加或移除变量的常量性，只能用于`指针`或`引用`，并且只能改变对象的`底层const`（`顶层const`，本身是const；`底层const`，指向对象const）
* `reinterpret_cast`: 一个指针类型转换为另一个不同类型的指针，常用于底层编程
